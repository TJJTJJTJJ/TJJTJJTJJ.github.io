<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="计算机组成原理">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理">
<meta property="og:url" content="http://example.com/2020/09/22/computer_system/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="计算机组成原理">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-22T15:20:26.000Z">
<meta property="article:modified_time" content="2020-09-22T15:54:43.206Z">
<meta property="article:author" content="TianJiajie">
<meta property="article:tag" content="408">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/09/22/computer_system/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机组成原理 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/22/computer_system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="TianJiajie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机组成原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-22 23:20:26 / 修改时间：23:54:43" itemprop="dateCreated datePublished" datetime="2020-09-22T23:20:26+08:00">2020-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/408/" itemprop="url" rel="index"><span itemprop="name">408</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>计算机组成原理<br><span id="more"></span></p>
<h3 id="4-1-4-文件的物理结构-文件分配方式-上"><a href="#4-1-4-文件的物理结构-文件分配方式-上" class="headerlink" title="4.1.4 文件的物理结构(文件分配方式)上"></a>4.1.4 文件的物理结构(文件分配方式)上</h3><p>操作系统对磁盘块的管理：</p>
<ol>
<li>对非空闲磁盘块的管理—文件的物理结构/文件分配方式</li>
<li>对空闲磁盘块的管理—文件存储空间管理</li>
</ol>
<p>文件的物理结构/文件分配方式：</p>
<ol>
<li>即文件数据如何存放在外存中，或者逻辑地址到物理地址的映射</li>
<li>连续分配</li>
<li>链接分配<br>3.1 隐式链接<br>3.2 显式链接</li>
<li>索引分配</li>
</ol>
<p>磁盘块vs内存块：磁盘中的存储单元也被分为一个个“磁盘块”。一般情况下，磁盘块的大小与内存块、页面的大小相同。内存与磁盘之间的数据交换都是以块为基本单位。</p>
<p>磁盘块vs文件块：在内存管理中，进程的逻辑地址被分为一个个页面，可以表示为(页面号, 块内地址)。在外存管理中，为了方便对文件数据的管理，文件的逻辑地址也被分为一个个的文件块，也可以表示为(逻辑块号，块内地址)。</p>
<p>用户通过逻辑地址操作自己的文件，而操作系统负责实现从<strong>逻辑地址到物理地址的映射</strong></p>
<p><strong>文件分配方式—连续分配</strong></p>
<p>连续分配实现每个文件在磁盘上占有一组连续的块</p>
<p>文件目录</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">文件名</th>
<th style="text-align:center">…</th>
<th style="text-align:center">起始块号</th>
<th style="text-align:center">长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">aaa</td>
<td style="text-align:center">…</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">bbb</td>
<td style="text-align:center">…</td>
<td style="text-align:center">10</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
</div>
<p>操作系统找到该文件的目录项(FCB)<br>物理块号=起始块号+逻辑块号</p>
<p>优点：连续分配方式支持顺序访问和直接访问(即随机访问)，顺序读写速度最快。<br>缺点：对文件的拓展不方便，存储利用率低，会产生磁盘碎片(紧凑技术)</p>
<p><strong>文件分配方式—链接分配</strong></p>
<p>链接分配采用离散分配的方式，为文件分配离散的磁盘块，分为隐式链接和显式链接两种。</p>
<p>链接分配—隐式链接</p>
<p>目录中记录文件的起始块号和结束块号，每个磁盘块都会保存指向下一个盘块的指针，这些指针对用户是透明的。</p>
<p>隐式链接只支持顺序访问，不支持随机访问。<br>不会产生碎片问题，方便拓展文件。</p>
<p>链接分配—显式链接</p>
<p>把用于链接文件各物理块的指针显式存放在一张表中，即文件分配表(FAT):物理块号—下一块，目录中只需要记录文件的起始块号。</p>
<p>一个磁盘仅设置一张FAT。开机时，FAT读入内存，并常驻内存。FAT的各个表项在物理上连续存储，且物理块号字段可以隐含。</p>
<p>采用显式链接方式的文件，支持顺序访问，也支持随机访问(多次访问FAT表，并不依次访问之前的磁盘块，块号的转换过程并不需要访问磁盘)，所以相比隐式链接来说，访问速度很快。<br>不会产生外部碎片，支持文件扩展。<br>文件分配表需要占用一定的存储空间</p>
<h3 id="4-1-4-文件的物理结构-文件分配方式-下"><a href="#4-1-4-文件的物理结构-文件分配方式-下" class="headerlink" title="4.1.4 文件的物理结构(文件分配方式)下"></a>4.1.4 文件的物理结构(文件分配方式)下</h3><p>操作系统对磁盘块的管理：</p>
<ol>
<li>对非空闲磁盘块的管理—文件的物理结构/文件分配方式</li>
<li>对空闲磁盘块的管理—文件存储空间管理</li>
</ol>
<p>文件的物理结构/文件分配方式：</p>
<ol>
<li>即文件数据如何存放在外存中，或者逻辑地址到物理地址的映射</li>
<li>连续分配</li>
<li>链接分配<br>3.1 隐式链接<br>3.2 显式链接</li>
<li>索引分配</li>
</ol>
<p><strong>文件分配方式—索引分配</strong></p>
<p>索引分配方式允许文件离散地分配在各个磁盘中，系统为每个文件建立一张索引表，索引表记录了文件的各个逻辑块对应的物理块(类似内存管理中的页面，记录逻辑页面到物理页面的映射)。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p>
<p>文件目录：文件名—索引块<br>索引表：逻辑块号—物理块号</p>
<p>显式链接：文件分配表FAT是一个磁盘对应一张表<br>索引分配：一个文件对应一张表</p>
<p>索引分配支持顺序访问和随机访问，支持文件扩展</p>
<p>假设磁盘块大小为1KB，一个索引表表项占4B，则一个磁盘块只能存放256个索引项。</p>
<p>索引块的大小是有限制的，如果文件太大，一张索引表太大，无法存储在一个索引块上时，需要以下方式解决：</p>
<ol>
<li>链接方案</li>
<li>多层索引</li>
<li>混合索引</li>
</ol>
<p><strong>文件分配方式—索引分配—链接方案</strong></p>
<p>如果索引表太大，一个索引块装不下，那么可以将多个索引块隐式链接存放，即索引块中存放指向下一个索引块的链接。</p>
<p>文件项：文件名—索引块</p>
<p>不支持随机访问，效率低<br>想要访问第i号索引块，必须先访问0~i-1号索引块，导致磁盘I/O次数太多</p>
<p><strong>文件分配方式—索引分配—多层索引</strong></p>
<p>建立多层索引，类似多级页表，使第一层指向第二层的索引块。</p>
<p>文件项：文件名—索引块(一级索引表)</p>
<p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。<br>若某文件采用两层索引，则该文件的最大长度可以到256 <em> 256 </em> 1KB=64MB</p>
<p>假设要访问1026号逻辑块，则 1026/256=4, 1026%256=2, 先将一级索引表调入内存，查询4号表项，将4号表项对应的磁盘块即二级索引表调入内存，再查询二级索引表的2号表项即可知道1026号逻辑块存放的磁盘块号。所以访问目标数据块，需要3次磁盘I/O</p>
<p>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作，相比链接方案少很多。</p>
<p>对于小文件，每次查询又太浪费磁盘查询次数。</p>
<p><strong>文件分配方式—索引分配—混合索引</strong></p>
<p>混合索引方式：多种索引分配方式的结合。既包含直接地址索引、一级间接索引(指向单层索引表)、两级间接索引(指向两层索引表)。</p>
<p>8个直接地址：一共对应8个磁盘块<br>一级间接索引：对应256个磁盘块<br>二级间接索引：对应256*256个磁盘块</p>
<p>这种结构的索引支持的最大文件长度为(8+256+256 <em> 256)</em>1KB=65800KB</p>
<p>若顶级索引表还没有读入内存<br>访问0~7号逻辑块：两次读磁盘<br>访问8~263：三次<br>访问264~65799：四次</p>
<p><strong>回顾</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">how</th>
<th style="text-align:center">目录项内容</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">顺序分配</td>
<td style="text-align:center">连续的磁盘块</td>
<td style="text-align:center">起始块号，文件长度</td>
<td style="text-align:center">顺序存取速度快、支持随机访问</td>
<td style="text-align:center">会产生碎片，不利于文件拓展</td>
</tr>
<tr>
<td style="text-align:center">隐式链接</td>
<td style="text-align:center">除文件的最后一个盘快外，每个盘快中都存有指向下一个盘块的指针</td>
<td style="text-align:center">起始块号、结束块号</td>
<td style="text-align:center">可以解决碎片问题，外存利用率高，文件扩展实现方便</td>
<td style="text-align:center">只能顺序访问，不能随机访问</td>
</tr>
<tr>
<td style="text-align:center">显式链接</td>
<td style="text-align:center">建立一张文件分配表FAT，显式记录盘块的先后关系，开机后FAT常驻内存</td>
<td style="text-align:center">起始块号</td>
<td style="text-align:center">除了拥有隐式链接的优点外，还可以通过查询内存中的FAT实现随机访问</td>
<td style="text-align:center">FAT需要占用一定的存储空间</td>
</tr>
<tr>
<td style="text-align:center">索引分配</td>
<td style="text-align:center">为文件数据块建立索引表，若文件太大，可以采用链接方案、多层索引、混合索引</td>
<td style="text-align:center">链接方案记录的是第一个索引块的块号，多层和混合索引记录的是顶级索引块的块号</td>
<td style="text-align:center">支持随机访问，易于实现文件的扩展</td>
<td style="text-align:center">索引表需要占用一定的存储空间。访问数据块钱需要先读入索引块。若采用链接方案，查找索引块需要很多次磁盘操作</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-1-5-文件存储管理"><a href="#4-1-5-文件存储管理" class="headerlink" title="4.1.5 文件存储管理"></a>4.1.5 文件存储管理</h3><p>操作系统对磁盘块的管理：</p>
<ol>
<li>对非空闲磁盘块的管理—文件的物理结构/文件分配方式</li>
<li>对空闲磁盘块的管理—文件存储空间管理</li>
</ol>
<p>文件存储空间管理</p>
<ol>
<li>存储空间的划分与初始化<br>1.1 文件卷(逻辑卷)概念<br>1.2 目录区与文件区</li>
<li>几种管理方法<br>2.1 空闲表法<br>2.2 空闲链表法：空闲盘块链、空闲盘区链<br>2.3 位示图法<br>2.4 成组链接法</li>
</ol>
<p>三个角度：</p>
<ol>
<li>用什么方式记录、组织空闲块</li>
<li>如何分配磁盘块</li>
<li>如何回收磁盘块</li>
</ol>
<p><strong>存储空间的划分与初始化</strong>：</p>
<p>磁盘分区：C盘、D盘等等<br>存储空间的划分：将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)<br>文件卷：包含目录区和文件区。目录区主要存放文件目录信息(FCB)、用于磁盘存取空间管理的信息<br>有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷</p>
<p><strong>存储空间管理—空闲表法</strong></p>
<p>用什么方式记录、组织空闲块？<br>用空闲盘块表记录空闲块区间：第一个空闲盘块号，空闲盘块数</p>
<p>如何分配磁盘块？<br>与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法为文件分配哪个区间。</p>
<p>如何回收磁盘块：与内存管理中的动态分区分配类似，回收时注意表项的合并问题。</p>
<p><strong>存储空间管理—空闲链表法</strong></p>
<p>空闲链表法：</p>
<ol>
<li>空闲盘块链：以盘块为单位组成一条空闲链，空闲盘块中存储这下一个空闲盘块的指针</li>
<li>空闲盘区链：以盘区(连续的盘块为一个盘区)为单位组成一条空闲链，空闲盘区中的第一个盘块记录了盘区的长度、下一个盘区的指针</li>
</ol>
<p>空闲盘块链：</p>
<p>记录：操作系统记录着链头、链尾指针<br>分配：链头分配，并修改空闲链的链头指针<br>回收：链尾回收，并修改空闲链的链尾指针<br>优点：适用于离散分配的物理结构，为文件分配多个盘块时需要重复多次操作</p>
<p>空闲盘区链：</p>
<p>记录：操作系统记录着链头、链尾指针<br>分配：可以采用首次适应、最佳适应等方法，从链头开始检索，按照算法规则找到一个符合要求的空闲盘区，或者将不同盘区的盘块同时分配给一个文件<br>回收：注意回收区与空闲盘区相邻</p>
<p><strong>存储空间管理—位示图法</strong></p>
<p>位示图：每个二进制位对应一个盘块。位示图一般采用连续的“字”表示。例如0表示空闲，1表示已分配，一个字的字长为16位，表示连续的16个磁盘的空闲情况，字中的每一位对应一个磁盘。因此可以用(字号，位号)对应一个盘块号，或者(行号，列号)<br>(i,j)—&gt;b:b=n*i+j, i=b/n, j=b%n</p>
<p>分配：顺序扫描位示图，找到K个相邻或者不相邻的空闲磁盘块，根据字号、位号算出对应的盘块号，将相应盘块分配给文件，将相应位设置为1<br>回收：根据回收的盘块号计算出对应的字号、位号，将相应位设置为0</p>
<p><strong>存储空间管理—成组链接法</strong></p>
<p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或者空闲链表可以太大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理</p>
<p>文件卷的目录区中专门用一个磁盘块作为超级块，当系统启动时需要将超级块读入内存，并且要保证内存与外存中的超级块数据一致。</p>
<p>超级块记录了：下一组空闲盘块数，对应的空闲块号。并且第一个空闲块的记录格式与超级块的格式相同(下一组空闲盘块数，对应的空闲块号)，即为新的“超级块”，其他空闲块则是简单的空闲块。或者说第一个空闲块是特殊的空闲块，用于套娃。<br>若当前“超级块”没有下一个“超级块”，第一个空闲块应该设置为某个特殊值，并且下一组空闲盘块数比正常的超级块的下一组空闲盘块数少1<br>超级块的下一组空闲盘块数有上限</p>
<p>分配：如果空闲盘块数比需求大，则直接分配，如果空闲盘块数等于需求，则复制下一级“超级块”的链接到超级块中<br>回收：如果可以放在超级块中，则放入超级块中，如果超级块已满，则复制超级块的链接到新的磁盘块，超级块指向新的磁盘块，此时超级块的下一组盘块数为1，将回收区放入超级块</p>
<h3 id="4-1-6-文件的基本操作"><a href="#4-1-6-文件的基本操作" class="headerlink" title="4.1.6 文件的基本操作"></a>4.1.6 文件的基本操作</h3><p>操作系统向上提供的最基本的功能：</p>
<ol>
<li>创建文件(create系统调用)</li>
<li>删除文件 delete</li>
<li>读文件 read</li>
<li>写文件 write</li>
<li>打开 open</li>
<li>关闭 close</li>
</ol>
<p><strong>创建文件</strong></p>
<ol>
<li>在外存中找到文件所需的空间</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</li>
</ol>
<p><strong>删除文件</strong></p>
<ol>
<li>找到文件名对应的目录项</li>
<li>确定回收文件占用的磁盘块</li>
<li>删除文件对应的目录项</li>
</ol>
<p><strong>打开文件</strong></p>
<ol>
<li>找到文件名对应的目录项，检查用户的操作权限</li>
<li>将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</li>
</ol>
<p>系统的打开文件表(整个系统只有一张)：编号，文件名…，打开计数器<br>用户进程的打开文件表：编号，文件名，…，系统表索引号<br>其中打开计数器用于记录该文件被几个进程打开，可以方便地实现某些文件管理的功能。</p>
<p>索引号也被称为文件描述符</p>
<p><strong>关闭文件</strong></p>
<ol>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器count减1，若count=0，则删除对应表项</li>
</ol>
<p><strong>读文件</strong></p>
<p>从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p>
<p><strong>写文件</strong></p>
<p>将文件数据从内存写入外存</p>
<h3 id="4-1-7-文件共享"><a href="#4-1-7-文件共享" class="headerlink" title="4.1.7 文件共享"></a>4.1.7 文件共享</h3><p>文件共享：</p>
<ol>
<li>基于索引结点的共享方式(硬链接)</li>
<li>基于符号链的共享方式(软链接)</li>
</ol>
<p><strong>基于索引结点的共享方式(硬链接)</strong></p>
<p>索引结点，是一种文件目录瘦身策略。将文件名之外的其他信息放到索引结点中。这样目录项只需要文件名、索引结点指针。</p>
<p>索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。</p>
<p>不同用户的目录指向同一个索引结点。<br>文件名可以不同。<br>删除文件时只是count减1.</p>
<p><strong>基于符号链的共享方式(软链接)</strong></p>
<p>Link类型的文件，记录共享文件的存放路径，可以简单理解成快捷方式，根据存放路径一层层找到共享文件。<br>如果共享文件删除，那么软链接文件还在，但是已经无法找到共享文件。<br>由于软链接的方式访问共享文件时需要查询多级目录，会有多次磁盘I/O，因此比较慢。</p>
<h3 id="4-1-8-文件保护"><a href="#4-1-8-文件保护" class="headerlink" title="4.1.8 文件保护"></a>4.1.8 文件保护</h3><p>文件保护：</p>
<ol>
<li>保护文件数据的安全</li>
<li>口令保护</li>
<li>加密保护</li>
<li>访问控制</li>
</ol>
<p><strong>口令保护</strong></p>
<p>口令一般存放在文件对应的FCB或者索引结点中<br>优点：空间开销和时间开销小<br>缺点：正确的口令存放在系统内部，不够安全</p>
<p><strong>加密保护</strong></p>
<p>使用密码对文件数据进行加密，解密后才能看到正确的数据<br>优点：保密性强，不需要在系统中存储密码<br>缺点：加密/解密需要一定的时间</p>
<p><strong>访问控制</strong></p>
<p>在每个文件的FCB或者索引结点中增加一个访问控制列表(Access-Control List, ACL)，该表中记录了各个用户可以对该文件执行哪些操作。</p>
<p>访问类型：</p>
<ul>
<li>读</li>
<li>写</li>
<li>执行：将文件装入内存并执行</li>
<li>添加</li>
<li>删除</li>
<li>列表清单：列出文件名和文件属性</li>
</ul>
<p>精简的访问列表：以组为单位，标记各组用户对文件的权限</p>
<h3 id="4-1-9-文件系统的层次结构"><a href="#4-1-9-文件系统的层次结构" class="headerlink" title="4.1.9 文件系统的层次结构"></a>4.1.9 文件系统的层次结构</h3><p>从上到下依次分为：</p>
<ol>
<li>用户接口：提供read等系统调用</li>
<li>文件目录系统：根据文件路径找到相应的FCB或者索引结点</li>
<li>存取控制模块：验证用户访问权限</li>
<li>逻辑文件系统与文件信息缓冲区：文件记录号—&gt;对应的逻辑地址</li>
<li>物理文件系统：逻辑地址—&gt;物理地址<br>6.1 辅助分配模块：分配和回收存储空间<br>6.2 设备管理程序模块：与硬件交互</li>
</ol>
<h2 id="4-2-磁盘"><a href="#4-2-磁盘" class="headerlink" title="4.2 磁盘"></a>4.2 磁盘</h2><h3 id="4-2-1-磁盘的结构"><a href="#4-2-1-磁盘的结构" class="headerlink" title="4.2.1 磁盘的结构"></a>4.2.1 磁盘的结构</h3><p>磁盘的结构：</p>
<ol>
<li>磁盘、磁道、扇区的概念</li>
<li>如何在磁盘中读/写数据</li>
<li>盘面、柱面的概念</li>
<li>磁盘的物理地址</li>
<li>磁盘的分类</li>
</ol>
<p>磁盘的盘面被划分成一个个磁道。<br>一个磁道又被划分成一个个扇区，每个扇区就是一个磁盘块。每个扇区存放的数据量相同</p>
<p>磁盘块的物理地址：(柱面号，盘面号，扇区号)</p>
<p>磁盘的分类：</p>
<ol>
<li>移动头磁盘、固定头磁盘</li>
<li>固定盘磁盘、可换盘磁盘</li>
</ol>
<h3 id="4-2-2-磁盘调度算法"><a href="#4-2-2-磁盘调度算法" class="headerlink" title="4.2.2 磁盘调度算法"></a>4.2.2 磁盘调度算法</h3><p>磁盘调度算法：</p>
<ol>
<li>一次磁盘读/写操作所需的时间<br>1.1 寻找时间<br>1.2 延迟时间<br>1.3 传输时间</li>
<li>磁盘调度算法<br>2.1 先来先服务 FCFS<br>2.2 最短寻找时间优先 SSTF<br>2.3 扫描算法 SCAN<br>2.4 循环扫描算法C-SCAN</li>
</ol>
<p><strong>一次磁盘读写操作所需的时间</strong></p>
<p>寻找时间(寻道时间) $T_s$</p>
<ol>
<li>启动磁道臂时间 s</li>
<li>移动磁头时间 m*n</li>
</ol>
<p>$T_s=s+m*n$</p>
<p>延迟时间 $T_R$</p>
<p>旋转磁盘时间，设转速为r，平均延迟时间 $T_R=1/(2r)$</p>
<p>传输时间 $T_t$</p>
<p>磁盘读出或者写入时间，设转速，设转速为r，读或写的字节数为b，每个磁道上的字节数为N。则：</p>
<p>$T_t=b/(rN)$</p>
<p><strong>扫描算法</strong></p>
<p>磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。</p>
<p>SCAN算法对各个位置的磁道的响应频率不平均</p>
<p><strong>LOOK算法</strong></p>
<p>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</p>
<p><strong>循环扫描算法C-SCAN</strong></p>
<p>磁头只能朝某个特定方向移动时才处理磁道访问请求，返回时快速移动到起始端而不处理任何请求。为了解决扫描算法对各个位置的磁道响应频率不平均的问题。</p>
<p><strong>C-LOOK算法</strong></p>
<h3 id="4-2-3-减少磁盘延迟时间的方法"><a href="#4-2-3-减少磁盘延迟时间的方法" class="headerlink" title="4.2.3 减少磁盘延迟时间的方法"></a>4.2.3 减少磁盘延迟时间的方法</h3><p>延迟时间：将目标扇区转到磁头下面所花的时间。或者说读入连续地址时，尽量减少时间。</p>
<p>磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的延迟时间。</p>
<p><strong>减少磁盘延迟时间的方法—交替编号</strong></p>
<p>逻辑上相邻的扇区在物理上有一定的间隔</p>
<p><strong>磁盘地址结构的设计</strong></p>
<p>为什么磁盘的物理地址是(柱面号，盘面号，扇区号)，而不是(盘面号，柱面号，扇区号)</p>
<p>假设某磁盘有8个柱面/磁道(假设最内侧柱面/磁道号为0)，4个盘面，8个扇区。则可以用3个二进制为表示柱面，2个二进制位表示盘面，3个二进制位表示扇区。</p>
<p>读取连续的物理地址(00,000,000)-(00,001,111)的扇区</p>
<p>(盘面号，柱面号，扇区号):</p>
<p>(00,000,000)-(00,000,111) 转两圈可读完<br>(00,001,000)-(00,001,111) 启动磁头臂，移动到下一个磁道</p>
<p>(柱面号，盘面号，扇区号):</p>
<p>(000,00,000)-(000,00,111) 转两圈可读完<br>(000,01,000)-(000,01,111) 激活相邻盘面的磁头</p>
<p>读取地址连续的磁盘块时，采用(柱面号，盘面号，扇区号)的地址结构可以减少磁头移动消耗的时间。</p>
<p><strong>减少磁盘延迟时间的方法—错位命名</strong></p>
<p>(000,00,111)-(000,01,000) 磁头读完0号盘面的111扇区，并经过一段时间的处理后，磁头已经划过1号盘面的000扇区。</p>
<p>所以0号盘面的0号扇区对应的时1号盘面的111扇区</p>
<h3 id="4-2-4-磁盘的管理"><a href="#4-2-4-磁盘的管理" class="headerlink" title="4.2.4 磁盘的管理"></a>4.2.4 磁盘的管理</h3><p>磁盘的管理：</p>
<ol>
<li>磁盘初始化</li>
<li>引导块</li>
<li>坏块的管理</li>
</ol>
<p><strong>磁盘初始化</strong></p>
<p>step1：低级格式化(物理格式化)。将磁盘的各个磁道划分为扇区。一个扇区通常可以分为头、数据区域(如512B)、尾三个部分组成。管理扇区的各种数据结构一般存放在头、尾两个部分，包括扇区校验码。<br>step2：磁盘分区。每个分区由若干个相邻柱面组成。<br>step3：逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构(如 位示图、空区分区表)</p>
<p><strong>引导块</strong></p>
<p>计算机开机的一系列初始化工作时通过执行初始化程序(自举程序)完成的。<br>初始化程序可以放在ROM(只读存储器)中。ROM的数据在出厂时就已经写入了，并且以后不能再修改。<br>ROM一般在出厂时就集成在主板上</p>
<p>完整的初始化程序放在ROM中会导致 ROM中的数据无法更改，不方便。<br>所以ROM只存放很小的 “自举装入程序”，完整的自举程序存放在磁盘的启动块(即引导块/启动分区)上，启动块位于磁盘的固定位置。<br>开机时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块，并将完整的“自举程序”装入内存，完成初始化。<br>拥有启动分区的磁盘称为启动磁盘或者系统磁盘</p>
<p><strong>坏块的管理</strong></p>
<p>坏块：坏了、无法正常使用的扇区。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</p>
<p>对于简单的磁盘，可以在逻辑格式化时(建立文件系统)对整个磁盘进行坏块检查，表明哪些扇区是坏扇区。比如，在FAT表中标明。(在这种方式中，坏块对操作系统不透明)</p>
<p>对于复杂的磁盘，磁盘控制器(磁盘设备内部的一个硬件部件)会维护一个坏块链表。磁盘出厂前进行低级格式化时就会将坏块链进行初始化。同时，会保留一些备用扇区，用于替换坏块。这种方案称为扇区备用。且这种方式中，坏块对操作系统不透明。</p>
<h1 id="5-I-O设备"><a href="#5-I-O设备" class="headerlink" title="5. I/O设备"></a>5. I/O设备</h1><h2 id="5-1-I-O设备"><a href="#5-1-I-O设备" class="headerlink" title="5.1 I/O设备"></a>5.1 I/O设备</h2><h3 id="5-1-1-I-O设备的基本概念和分类"><a href="#5-1-1-I-O设备的基本概念和分类" class="headerlink" title="5.1.1 I/O设备的基本概念和分类"></a>5.1.1 I/O设备的基本概念和分类</h3><p>操作系统提供的功能：</p>
<ol>
<li>处理机管理</li>
<li>存储器管理</li>
<li>文件管理</li>
<li>设备管理</li>
</ol>
<p>I/O设备的基本概念和分类</p>
<ol>
<li>什么是I/O设备</li>
<li>按使用特性分类</li>
<li>按传输速率分类</li>
<li>按信息交换的单位分类</li>
</ol>
<p><strong>什么是I/O设备</strong></p>
<p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作系统的方式对外部设备进行操作。</p>
<p>Write操作：向外部设备写出数据<br>Read操作：向外部设备读入数据</p>
<p><strong>按使用特性分类</strong></p>
<p>人机交互类外部设备<br>存储设备<br>网络通信设备</p>
<p><strong>按信息交换的单位分类</strong></p>
<p>块设备：以块为单位，可寻址，即可以随机地读写任一块，例如磁盘<br>字符设备：以字符为单位，不可寻址，输入输出常采用中断驱动方式，例如键盘</p>
<h3 id="5-1-2-I-O控制器"><a href="#5-1-2-I-O控制器" class="headerlink" title="5.1.2 I/O控制器"></a>5.1.2 I/O控制器</h3><p>I/O设备：</p>
<ol>
<li>机械单位</li>
<li>电子部件：I/O控制器(又称为设备控制器)</li>
</ol>
<p>CPU无法直接控制I/O设备，需要通过I/O控制器(又称为设备控制器)控制设备。</p>
<p>I/O控制器的功能：</p>
<ol>
<li>接受和识别CPU发出的命令：控制寄存器</li>
<li>向CPU报告设备的状态：状态寄存器</li>
<li>数据交换：数据寄存器</li>
<li>地址识别：用于识别哪个寄存器</li>
</ol>
<p>I/O控制器的组成：</p>
<ol>
<li>CPU与控制器的接口</li>
<li>I/O逻辑：负责接受和识别CPU命令，并负责对设备发出命令</li>
<li>控制器与设备的接口1, 2,…, i (多个接口)</li>
</ol>
<p>备注：</p>
<ol>
<li>一个I/O控制可能会对应多个设备</li>
<li>数据寄存器、控制寄存器、状态寄存器可能有多个(每个控制/状态寄存器对应一个具体的设备)，且这些寄存器都要有相应的地址，才能方便CPU操作。</li>
<li>寄存器编址：<br>3.1 或者让这些寄存器占用内存地址的一部分，称为内存映像I/O，可以采用对内存进行操作的指令对控制器进行操作<br>3.2 或者采用I/O专用地址，即寄存器独立编址，需要设置专门的指令操作控制器</li>
</ol>
<h3 id="5-1-3-I-O控制方式"><a href="#5-1-3-I-O控制方式" class="headerlink" title="5.1.3 I/O控制方式"></a>5.1.3 I/O控制方式</h3><p>I/O控制方式</p>
<ol>
<li>程序直接控制方式</li>
<li>中断驱动方式</li>
<li>DMA方式</li>
<li>通道控制方式</li>
</ol>
<p>考察点：</p>
<ol>
<li>完成一次读写操作的流程</li>
<li>CPU干预的频率</li>
<li>数据传送的单位</li>
<li>数据的流向</li>
<li>优缺点</li>
</ol>
<p><strong>程序直接控制方式</strong></p>
<p>完成一次读写操作的流程：轮询</p>
<ol>
<li>CPU向控制器发出读指令，设备启动，并且状态寄存器设为1(未就绪)</li>
<li>轮询检查控制器的状态。若是1，说明还没有准备好要输入的数据</li>
<li>输入设备准备好数据后将数据传给控制器，并报告自身状态</li>
<li>控制器将输入的数据放到数据寄存器中，并将状态改为0(已就绪)</li>
<li>CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器中，再把CPU寄存器中的内容放入内存。</li>
</ol>
<p>CPU干预的频率：</p>
<p>很频繁，I/O开始之前、完成之后都需要CPU介入，<br>在等待I/O完成的过程中CPU需要不断地轮询检查。</p>
<p>数据传送的单位：字</p>
<p>数据的流向：</p>
<p>读：I/O设备—&gt;CPU—&gt;内存<br>写：内存—&gt;CPU—&gt;I/O设备<br>每个字的读写都需要CPU帮助</p>
<p>优点：实现简单<br>缺点：CPU利用率低</p>
<p><strong>中断驱动方式</strong></p>
<p>引入中断机制。</p>
<p>CPU发出读写指令后，将等待I/O的进程阻塞，执行其他进程。当I/O完成后，控制器向CPU发出一个中断信号，CPU检测到中断信号，会转去执行中断处理程序处理该中断。处理中断的过程中，CPU从I/O控制器读一个字的数据传送到CPU寄存器，再写入主存。</p>
<p>备注：</p>
<ol>
<li>CPU会在每个指令周期的末尾检查中断</li>
<li>中断处理过程中需要保存、恢复进程的运行环境</li>
</ol>
<p>CPU干预的频率：</p>
<p>每次I/O操作开始之前、完成之后需要CPU介入。<br>等待I/O完成的过程中CPU可以切换到别的进程执行。</p>
<p>数据传送的单位：字</p>
<p>数据的流向：</p>
<p>读操作：I/O设备—&gt;CPU—&gt;内存<br>写操作：内存—&gt;CPU—&gt;I/O设备</p>
<p>优点：CPU与I/O设备可以并行工作<br>缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而且贫寒的中断处理会消耗较多的CPU时间</p>
<p><strong>DMA方式</strong></p>
<p>与“中断驱动方式”相比，DMA方式(Direct Memory Access 直接存储器存取。主要用于块设备的I/O控制)有几个改进：</p>
<ol>
<li>数据的传送单位是块</li>
<li>数据的流向是 设备&lt;—&gt;内存，不需要CPU作为中转站</li>
<li>仅在传送一个或者多个数据块的开始和结束时，才需要CPU干预</li>
</ol>
<p>开始：CPU 指明此次要进行的操作；结束：控制器完成操作后，向CPU发出中断信号</p>
<p>DMA控制器的组成：</p>
<ol>
<li>主机-控制器接口<br>DR 数据寄存器<br>MAR 内存地址寄存器<br>DC 数据计数器<br>CR 命令/状态寄存器<br>2</li>
</ol>
<p>磁盘和内存之间的数据传送单位：字</p>
<p>CPU干预的频率：仅在传送一个或者多个数据块的开始或者结束时</p>
<p>数据传送的单位：</p>
<p>每次读写一个或者多个块(注意：每次读写的只能是连续的多个块，且这些块读入内存后，在内存中也必须是连续的)</p>
<p>数据流向：I/O设备&lt;—&gt;内存</p>
<p>优点：数据传输效率进一步增加，CPU与I/O设备的并行性得到提升<br>缺点：CPU的一条I/O指令，只能读写一个或者多个连续的数据块。</p>
<p><strong>通道控制方式</strong></p>
<p>通道：一种硬件，可以理解为 弱鸡版的CPU。通道可以识别并执行一系列通道指令。</p>
<ol>
<li>CPU向通道发出I/O指令。仅仅指明通道程序在内存中的位置，并指明要操作的是哪个I/O设备。之后CPU就切换到其他进程执行了。</li>
<li>通道执行内存中的通道程序(完整的程序在内存中，CPU仅仅发出简单的I/O指令，记录了要读入写出的数据以及对应的地址)</li>
<li>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理。</li>
</ol>
<p>CPU干预的频率：</p>
<p>极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读写后才需要发出中断信号，请求CPU干预。</p>
<p>数据传送的单位：每次读写一组数据块</p>
<p>数据的流向：(在通道的控制下进行)：I/O 设备&lt;—&gt;内存</p>
<p>缺点：实现复杂，需要专门的通道硬件支持<br>优点：CPU、通道、I/O设备可以并行工作，资源利用率很高</p>
<p>一个通道可以控制多个I/O控制器，一个I/O控制器可以控制多个设备。</p>
<h3 id="5-1-4-I-O软件层次结构"><a href="#5-1-4-I-O软件层次结构" class="headerlink" title="5.1.4 I/O软件层次结构"></a>5.1.4 I/O软件层次结构</h3><p>I/O软件的层次</p>
<ol>
<li>用户层软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
<li>硬件</li>
</ol>
<p>其中 设备独立性软件、设备驱动程序、中断处理程序 属于 操作系统的内核部分，属于核心态，称为 I/O系统，或称 I/O 核心子系统<br>用户层软件 属于 用户态</p>
<p><strong>用户层软件</strong></p>
<p>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作，比如printf函数</p>
<p><strong>设备独立性软件</strong></p>
<p>设备独立性软件向上提供 系统调用，例如write系统调用。用户层软件将用户请求翻译成格式化的I/O请求，并通过系统调用请求操作系统内核的服务。</p>
<p>Windows操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用(Windows API)</p>
<p>设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在都这一层实现。</p>
<p>设备独立性软件主要实现的功能：</p>
<ol>
<li>向上层提供统一的调用接口(read/write等)</li>
<li>设备保护(权限保护)</li>
<li>差错管理</li>
<li>设备的分配与回收</li>
<li>数据缓冲区管理：通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li>
<li>建立逻辑设备名到物理设备名的映射关系：通过逻辑设备表LUT，确定逻辑设备对应的物理设备，并根据设备类型选择调用相应的驱动程序，比如 打印机1/打印机2。逻辑设备名以文件的形式存在。可以为一个系统或者一个用户设置一张逻辑设备表。</li>
</ol>
<p><strong>设备驱动程序</strong></p>
<p>设备驱动程序：主要负责对硬件设备的具体控制，将上层发出的一系列命令(read)转化为特定设备能识别的操作。设置设备寄存器、检查设备状态。</p>
<p>不同I/O设备有不同的硬件特性，具体细节只有设备的厂家知道。</p>
<p>驱动程序一般会以一个独立进程的方式存在。</p>
<p><strong>中断处理程序</strong></p>
<p>当I/O任务完成时，I/O控制会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</p>
<p>中断处理程序的处理流程如下：</p>
<p>从控制器读出设备状态—&gt;I/O正常结束—&gt;是—&gt;从设备中读入一个字的数据并经由CPU放到内存缓冲区<br>—&gt;否—&gt;根据异常原因做相应处理</p>
<p>中断处理程序可以与硬件直接接触</p>
<p><strong>硬件</strong></p>
<p>I/O控制器</p>
<h3 id="5-1-5-I-O核心子系统"><a href="#5-1-5-I-O核心子系统" class="headerlink" title="5.1.5 I/O核心子系统"></a>5.1.5 I/O核心子系统</h3><p>I/O核心子系统：包括设备独立性软件、设备驱动程序、中断处理程序，这些程序属于操作系统的内核部分，即I/O系统</p>
<p>功能：</p>
<ol>
<li>I/O调度</li>
<li>设备保护</li>
<li>假脱机技术(SPOOLing)</li>
<li>设备分配与回收</li>
<li>缓冲区管理(缓冲与高速缓存)</li>
</ol>
<p>I/O软件的层次</p>
<ol>
<li>用户层软件：假脱机技术</li>
<li>设备独立性软件：I/O调度、设备保护、设备分配与回收、缓冲区管理</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
<li>硬件</li>
</ol>
<h3 id="5-1-6-假脱机技术"><a href="#5-1-6-假脱机技术" class="headerlink" title="5.1.6 假脱机技术"></a>5.1.6 假脱机技术</h3><p>假脱机技术</p>
<ol>
<li>什么是假脱机技术，脱机技术可以解决什么问题</li>
<li>假脱机技术的实现原理<br>2.1 输入井和输出井<br>2.2 输入进程和输出进程<br>2.3 输入缓冲区和输出缓冲区</li>
<li>共享打印机的原理分析</li>
</ol>
<p><strong>脱机</strong></p>
<p>脱机：脱离主机的控制的输入/输出操作，由外围控制机进行控制。</p>
<p>脱机技术，缓解了CPU与慢速I/O设备之间的设备，可以提前输入或者输出到外围设备。</p>
<p><strong>假脱机技术</strong></p>
<p>假脱机技术，又称SPOOLing技术，用软件的技术模拟脱机技术。</p>
<p>输入数据：输入设备—&gt;输入缓冲区(内存)—&gt;输入井(磁盘)<br>输出数据：输出设备&lt;—输出缓冲区(内存)&lt;—输出井(磁盘)</p>
<p>在输入进程(外围控制机)的控制下，输入缓冲区用于暂存从输入设备输入的数据，之后在转存到输入井中<br>在输出进程(外围控制机)的控制下，输出缓冲区用于暂存从输出井送来的数据，之后在传送到输出设备上</p>
<p><strong>共享打印机原理分析</strong></p>
<p>独占式设备：只允许各个进程串行使用的设备<br>共享设备：允许多个进程同时使用的设备</p>
<p>当多个进程提出打印请求时，假脱机管理进程为每个进程做两件事：</p>
<ol>
<li>在磁盘输出井中为进程申请一个空闲缓冲区(在磁盘上)，输入要打印的数据</li>
<li>为用户进程申请一张空白的打印请求表，填入打印请求，并将该表挂到假脱机文件队列上</li>
<li>当打印机空闲时，输出进程按表中的要求将打印的数据从输出井经输出缓冲区输出到打印机。</li>
</ol>
<p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备</p>
<h3 id="5-1-7-设备的分配与回收"><a href="#5-1-7-设备的分配与回收" class="headerlink" title="5.1.7 设备的分配与回收"></a>5.1.7 设备的分配与回收</h3><p>设备的分配与回收</p>
<ol>
<li>设备分配时应考虑的因素</li>
<li>静态分配与动态分配</li>
<li>设备分配管理中的数据结构</li>
<li>设备分配的步骤</li>
<li>设备分配步骤的改进方法</li>
</ol>
<p><strong>设备分配时应该考虑的因素</strong></p>
<ol>
<li>设备的固有属性</li>
<li>设备分配算法</li>
<li>设备分配中的安全性</li>
</ol>
<p>设备的固有属性：独占设备、共享设备、虚拟设备<br>设备的分配算法：先来先服务等<br>设备分配中的安全性：安全分配方式(阻塞)、不安全分配方式(不阻塞)</p>
<p><strong>静态分配和动态分配</strong></p>
<p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源<br>动态分配：进行运行过程中动态申请设备资源</p>
<p><strong>设备分配管理中的数据结构</strong></p>
<p>一个通道可以控制多个设备控制器，每个设备控制器可以控制多个设备</p>
<p>设备控制表<br>控制器控制表<br>通道控制表<br>系统设备表</p>
<p>设备控制表(DCT)：系统为每个设备配置一张DCT，用于记录设备情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">设备控制表DCT</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">设备类型</td>
<td style="text-align:center">如 打印机/扫描仪</td>
</tr>
<tr>
<td style="text-align:center">设备标示符</td>
<td style="text-align:center">物理设备名，唯一</td>
</tr>
<tr>
<td style="text-align:center">设备状态</td>
<td style="text-align:center">忙碌/空闲/故障</td>
</tr>
<tr>
<td style="text-align:center">指向控制器表的指针</td>
<td style="text-align:center">每个设备由一个控制器控制</td>
</tr>
<tr>
<td style="text-align:center">重复执行次数或时间</td>
<td style="text-align:center">当重复执行多次I/O操作仍不成功，才认为此次I/O失败</td>
</tr>
<tr>
<td style="text-align:center">设备队列的队首指针</td>
<td style="text-align:center">指向等待该设备的进程队列(由进程PCB组成队列)</td>
</tr>
</tbody>
</table>
</div>
<p>系统会根据阻塞原因不同，将进程PCB挂到不同的阻塞队列中</p>
<p>控制器控制表(COCT)：每个设备控制器对应一张COCT。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">控制器控制表COCT</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">控制器标识符</td>
<td style="text-align:center">各个控制器的唯一ID</td>
</tr>
<tr>
<td style="text-align:center">控制器状态</td>
<td style="text-align:center">忙碌/空闲/故障…</td>
</tr>
<tr>
<td style="text-align:center">指向通道表的指针</td>
<td style="text-align:center">每个控制器由一个通道控制</td>
</tr>
<tr>
<td style="text-align:center">控制器队列的队首指针</td>
<td style="text-align:center">指向正在等待该控制器的进程队列(由进程PCB组成队列)</td>
</tr>
<tr>
<td style="text-align:center">控制器队列的队尾指针</td>
</tr>
</tbody>
</table>
</div>
<p>通道控制表(CHCT)：每个通道对应一张CHCT</p>
<p>通道控制表：通道标识符、通道状态、与通道连接的控制器表首址、通道队列的队首指针、通道队列的队尾指针</p>
<p>系统设备表(SDT)：记录了系统中全部设备的情况，每个设备对应一个表目</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">系统设备表(SDT)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">表目1</td>
</tr>
<tr>
<td style="text-align:center">表目2</td>
</tr>
<tr>
<td style="text-align:center">表目i</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">表目i</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">设备类型(逻辑设备名)</td>
</tr>
<tr>
<td style="text-align:center">设备标识符(物理设备名)</td>
</tr>
<tr>
<td style="text-align:center">DCT 设备控制表</td>
</tr>
<tr>
<td style="text-align:center">驱动程序入口</td>
</tr>
</tbody>
</table>
</div>
<p><strong>设备分配的步骤</strong></p>
<ol>
<li>根据进程请求的物理设备名查找SDT，物理设备名时进程请求分配设备时提供的参数</li>
<li>根据SDT找到设备控制表DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程</li>
<li>根据设备控制表DCT找到控制器控制表COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li>
<li>根据控制器控制表COCT找到通道控制表CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li>
<li>只有设备、控制器、通道三者都分配成功时，这次设备才算成功，之后便可启动I/O设备</li>
</ol>
<p>缺点：</p>
<ol>
<li>用户编程时必须使用 物理设备名，底层细节对用户不透明，不方便编程</li>
<li>若换了一个设备，则程序无法运行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待。</li>
</ol>
<p><strong>设备分配步骤的改进</strong></p>
<p>建立逻辑设备名与物理设备名的映射机制，用户编程时只需要提供逻辑设备名</p>
<ol>
<li>根据进程请求提供的逻辑设备名查找系统设备表SDT</li>
<li>查找SDT，找到用户进程指定类型且空闲的设备，将其分配给进程。操作系统在逻辑设备表LUT中新增一个表项</li>
<li>根据设备控制表DCT找到控制器控制表COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li>
<li>根据控制器控制表COCT找到通道控制表CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li>
</ol>
<p>逻辑设备表LUT</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">逻辑设备名</th>
<th style="text-align:center">物理设备名</th>
<th style="text-align:center">驱动程序入口地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/dev/打印机</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1024</td>
</tr>
</tbody>
</table>
</div>
<p>逻辑设备表LUT建立了逻辑设备名与物理设备名之间的映射关系。</p>
<p>逻辑设备表LUT的设置问题：一个系统一张或者一个用户一张</p>
<h3 id="5-1-8-缓冲区管理"><a href="#5-1-8-缓冲区管理" class="headerlink" title="5.1.8 缓冲区管理"></a>5.1.8 缓冲区管理</h3><p>缓冲区管理：</p>
<ol>
<li>什么是缓冲区？有什么作用？</li>
<li>单缓冲</li>
<li>双缓冲</li>
<li>循环缓冲</li>
<li>缓冲池</li>
</ol>
<p><strong>缓冲器及其作用</strong></p>
<p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区</p>
<p>硬件寄存器：成本高、容量小、速度快，如 联想寄存器存放页表项的副本<br>内存缓冲区：设备独立性软件的缓冲区管理</p>
<p>缓冲区的作用：</p>
<ol>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ol>
<p><strong>单缓冲</strong></p>
<p>假设某用户进程请求某种块设备读入若干块的数据。<br>若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区，一个缓冲区的大小就是一个块。</p>
<p>数据：块设备—输入T—&gt;缓冲区—传送M—&gt;用户进程的工作区—处理C—&gt;CPU</p>
<p>消耗时间 max(T,C)+M</p>
<p>分析方法：假定一个初始状态，下一次达到该状态所需的时间</p>
<p><strong>双缓冲</strong></p>
<p>双缓冲，操作系统在主存中为其分配两个缓冲区</p>
<p>耗时：max(T, C+M)</p>
<p>单缓冲只能实现同一时刻的单通信<br>双缓冲能实现同一时刻的双向传输</p>
<p><strong>循环缓冲区</strong></p>
<p>将多个大小相等的缓冲区链接成一个循环队列</p>
<p>in指针，指向下一个可以冲入数据的空缓冲区<br>out指针，指向下一个可以取出数据的满缓冲区</p>
<p><strong>缓冲池</strong></p>
<p>缓冲池由系统中的缓冲区组成。三个队列、四种工作缓冲区</p>
<p>按使用状态分为：空缓冲队列、装满输入数据的缓冲队列(输入队列)、装满输出数据的缓冲队列(输出队列)</p>
<p>按扮演功能又分为：用于收容输入数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区(sin)、用于收容输出数据的工作缓冲区(hout)、用于提取输出数据的工作缓冲区(sout)</p>
<p>输入进程请求输入数据<br>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区 hin，充满数据后将缓冲区挂到输入队列队尾</p>
<p>计算进程想要取得一块输入数据<br>从输入队列中取得一块冲满输入数据的缓冲区作为提取输入数据的工作缓冲区sin。缓冲区读空后挂到空缓冲区队列</p>
<p>计算进程想要准备号的数据冲入缓冲区<br>空缓冲队列—&gt;收容输出数据的工作缓冲区hout—&gt;输出队列</p>
<p>输出进程请求输出数据<br>输出队列—&gt;提取输出数据的工作缓冲区sout—&gt;空缓冲队列</p>
<p>hin、sout：I/O设备<br>sin、hout：用户进程</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/408/" rel="tag"># 408</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/22/java/" rel="prev" title="java参考">
      <i class="fa fa-chevron-left"></i> java参考
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/22/TVOS/" rel="next" title="TVOS">
      TVOS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-%E4%B8%8A"><span class="nav-number">1.</span> <span class="nav-text">4.1.4 文件的物理结构(文件分配方式)上</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F-%E4%B8%8B"><span class="nav-number">2.</span> <span class="nav-text">4.1.4 文件的物理结构(文件分配方式)下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-5-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">4.1.5 文件存储管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-6-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">4.1.6 文件的基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-number">5.</span> <span class="nav-text">4.1.7 文件共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-8-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="nav-number">6.</span> <span class="nav-text">4.1.8 文件保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">7.</span> <span class="nav-text">4.1.9 文件系统的层次结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E7%A3%81%E7%9B%98"><span class="nav-number"></span> <span class="nav-text">4.2 磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">4.2.1 磁盘的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">4.2.2 磁盘调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E5%87%8F%E5%B0%91%E7%A3%81%E7%9B%98%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">4.2.3 减少磁盘延迟时间的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-%E7%A3%81%E7%9B%98%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">4.2.4 磁盘的管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-I-O%E8%AE%BE%E5%A4%87"><span class="nav-number"></span> <span class="nav-text">5. I&#x2F;O设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-I-O%E8%AE%BE%E5%A4%87"><span class="nav-number"></span> <span class="nav-text">5.1 I&#x2F;O设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">5.1.1 I&#x2F;O设备的基本概念和分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">5.1.2 I&#x2F;O控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">5.1.3 I&#x2F;O控制方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">5.1.4 I&#x2F;O软件层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-I-O%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">5.1.5 I&#x2F;O核心子系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-6-%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="nav-number">6.</span> <span class="nav-text">5.1.6 假脱机技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-7-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">7.</span> <span class="nav-text">5.1.7 设备的分配与回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-8-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">5.1.8 缓冲区管理</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">TianJiajie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianJiajie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
