<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="0. 前言钟准团队的CCPR2019文章，牛逼。思想有一丢丢类似聚类，但是比聚类强的是，赋予了id。与HHL文章有很大的不同。什也不说了，虚心学习。  paper: CVPR2019_Invariance Matters Exemplar Memory for Domain Adaptive Person Re-identification code: pytorch">
<meta property="og:type" content="article">
<meta property="og:title" content="ECN">
<meta property="og:url" content="http://example.com/2019/05/06/ECN/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0. 前言钟准团队的CCPR2019文章，牛逼。思想有一丢丢类似聚类，但是比聚类强的是，赋予了id。与HHL文章有很大的不同。什也不说了，虚心学习。  paper: CVPR2019_Invariance Matters Exemplar Memory for Domain Adaptive Person Re-identification code: pytorch">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2019/05/06/ECN/framework.png">
<meta property="og:image" content="http://example.com/2019/05/06/ECN/temperature.png">
<meta property="og:image" content="http://example.com/2019/05/06/ECN/weight.png">
<meta property="og:image" content="http://example.com/2019/05/06/ECN/number.png">
<meta property="og:image" content="http://example.com/2019/05/06/ECN/MSMT.png">
<meta property="article:published_time" content="2019-05-06T07:32:26.000Z">
<meta property="article:modified_time" content="2019-06-03T09:20:33.708Z">
<meta property="article:author" content="TianJiajie">
<meta property="article:tag" content="person re-id">
<meta property="article:tag" content="cross domain">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2019/05/06/ECN/framework.png">

<link rel="canonical" href="http://example.com/2019/05/06/ECN/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ECN | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/06/ECN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="TianJiajie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ECN
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-06 15:32:26" itemprop="dateCreated datePublished" datetime="2019-05-06T15:32:26+08:00">2019-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-06-03 17:20:33" itemprop="dateModified" datetime="2019-06-03T17:20:33+08:00">2019-06-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/preson-re-id/" itemprop="url" rel="index"><span itemprop="name">preson re-id</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>钟准团队的CCPR2019文章，牛逼。思想有一丢丢类似聚类，但是比聚类强的是，赋予了id。与HHL文章有很大的不同。什也不说了，虚心学习。</p>
<ul>
<li>paper: <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1904.01990">CVPR2019_Invariance Matters Exemplar Memory for Domain Adaptive Person Re-identification</a></li>
<li>code: <a target="_blank" rel="noopener" href="https://github.com/zhunzhong07/ECN">pytorch</a></li>
</ul>
<span id="more"></span>
<ul>
<li>[x] 2019-06-03: 这篇文章和 <a target="_blank" rel="noopener" href="https://tjjtjjtjj.github.io/2019/03/27/One-Example-reID/#more">One Example reID</a> 有些相似啊。感觉大家的论文之间的联系错综复杂。</li>
</ul>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>作者的注意力还是集中在如何区分 target domain 中的图片。考虑了三个因素，exemplar-invariance, camera-invariance and neighborhood-invariance. 可以简单地理解成每个人是一类，StarGAN生成的图片是一类，特征相似的是一类，并且为了实现上述目标，需要存储 target domain 中 train 数据集的所有特征，这一点有点疑问，需要的存储空间和计算时间消耗大吗？作者在第一节的最后有解答，消耗的空间和时间都很小。等自己实验的时候就知道了。它是用了两个分类器，一个用于训练 source 数据集， label 是 source 的label，一个用于训练 target 数据集， label 是 target 的label，两个label不一样。网络模型与HHL略有不同。</p>
<p>第一，通过分类损失使 target domain 的图片全部可分。分类模型学到的更可能是图片视觉上的相似性而不是语义相似性，并且数据集中同一id的图片在视觉上变化很大，所以，索性将target数据集上的每张图片作为一类，迫使不同id的相似图片变得不相似。行吧，这个理由，(⊙o⊙)…，怎么有点牵强吧，因为和后面的特征相似的作为一类有一丢丢矛盾。不对，有点类似既然不知道你们的id，那就把让你们之间先全部可分，这个思路在哪篇论文见过，想不起来了。</p>
<p>第二，同一 content 不同 camera style 的图片视为一类。这个和HHL的数据集处理方法一样，用 StarGAN 生成同一图片在不同 camera 下的图片，并视为一类，因为刚刚对图片使用了分类损失，所以这时候可以直接用到分类损失上，而不用再考虑三元组损失，(我觉得可能是基于分类损失的作用一直大于二元组损失，三元组损失)，这时可以保证同一 content 不同 camera style 的图片视为一类。这时 StarGAN 生成图片中的人的形态等基本保留，感觉更多是亮度上的变化(肉眼可见)，偶尔会有衣服颜色的变换，但是不能变换这个人的姿势，比如正面走变成侧面走这种，HHL 已经证明了 camera style 的影响，但是我觉得姿势的变换也是一个重要的因素才对，因为分类模型的起家就是识别同一类物体不同形态的图片。好像 CVPR 2019 这个团队有做这方面的内容，抽空膜拜一波。</p>
<p>第三，k近邻的图片视为一类。这应该像是之间看到的一些关于聚类的或者k近邻的论文，总体思想是因为不知道图片的真id，那就可能赋予一个比较接近真实的id，又因为同一id的图片的特征应该是临近的，所以把临近的图片作为同一id也不过分，其实有的论文用的是聚类，但本质是一样的。</p>
<p>我觉得钟准厉害的地方不仅仅是能想到这三个创新点，更重要的是能把这三个创新点融合到一起，因为这三个创新点在别的论文里或多或少都可以看到影子，但是因为实现的的方法、思路、具体过程都不一样，很难看见一个创新点就把融到一起，看到一个想法就放到自己的模型里，或者看到一个idea就觉得有用并且一试还真有用，并能给出属于自己的解释，而不是明显的生搬硬造，比如这里的 memory module 很有想法。</p>
<h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>Unsupervised domain adaptation. 一种方法是对齐两个域的特征，其基本假设是源域和目标域的类别一样。另一种方法是丢弃目标域的未知类别样本，学习源域到目标域的映射。</p>
<p>Unsupervised person re-identification. <a target="_blank" rel="noopener" href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Zhun_Zhong_Generalizing_A_Person_ECCV_2018_paper.pdf">ECCV2018_HHL</a> 可能忽略了 target domain 中其他因素对 id 的影响，比如姿势等。与 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1808.07301.pdf">BMVC2018_DAL</a> 不同的是，作者设计了软分类损失。</p>
<h2 id="3-The-Proposed-Method"><a href="#3-The-Proposed-Method" class="headerlink" title="3. The Proposed Method"></a>3. The Proposed Method</h2><p>简单定义下数学符号，直接用英文吧，能知道就行。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数学符号</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\lbrace X_s, Y_s \rbrace, N_s$</td>
<td style="text-align:center">source domain, $N<em>s$ person images, $(x</em>{si}, y_{s,i})$, $M$ person identities</td>
</tr>
<tr>
<td style="text-align:center">$X_t, N_t$</td>
<td style="text-align:center">target domain, $N_t$ person images</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-1-Overview-of-Framework"><a href="#3-1-Overview-of-Framework" class="headerlink" title="3.1 Overview of Framework"></a>3.1 Overview of Framework</h3><img src="/2019/05/06/ECN/framework.png" class title="Framework of the proposed approach">
<p>其实模型没有画的这么复杂，基本还是保留ResNet-50的基本网络，后面加个FC-4049，FC-#id/ exemplar memory，其中FC-#id用于 source domain 的数据， exemplar memory 用于计算 target domain 的数据，等下直接看代码一目了然。</p>
<h3 id="3-2-Supervised-Learning-for-Source-Domain"><a href="#3-2-Supervised-Learning-for-Source-Domain" class="headerlink" title="3.2 Supervised Learning for Source Domain"></a>3.2 Supervised Learning for Source Domain</h3><p>这个容易理解， source domain 直接用个分类损失。</p>
<script type="math/tex; mode=display">L_{src}=-\frac{1}{n_s}\sum_{i=1}^{n_s}\log p(y_{s,i}|x_{s,i})</script><h3 id="3-3-Exemplar-Memory"><a href="#3-3-Exemplar-Memory" class="headerlink" title="3.3 Exemplar Memory"></a>3.3 Exemplar Memory</h3><p>Exemplar Memory 借鉴的是 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1604.01850v3">Joint Detection and Identification Feature Learning for Person Search</a>，（已经有两篇论文没有看过了，自己菜不是没有原因的），采用的是 key-value 架构 $K,V$，其中在 key-memory 中存储每张图片的 FC-4096 特征， value-memory 中存储图片的lable，其中视每张图片为一类，index 即为 label。key-memory 中的特征初始化成0，value-memory 初始化成 $V[i]=i$，并且在整个训练过程中保持不变。key-memory 的更新策略是:</p>
<script type="math/tex; mode=display">K[i]\gets \alpha K[i]+(1-\alpha)f(x_{t,i})</script><p>其中$\alpha\in [0,1]$，$K[i]\gets \parallel K[i] \parallel_2$，也就是每次都会进行一次归一化。这里的 $\alpha$ 是线性变化的，初始化为 0.01, 后续变化为 $\alpha = 0.01*epoch $。其中每次更新都是发生在反向传播时，顺便进行更新的。写的很巧妙。</p>
<h3 id="3-4-Invariance-Learning-for-Target-Domain"><a href="#3-4-Invariance-Learning-for-Target-Domain" class="headerlink" title="3.4 Invariance Learning for Target Domain"></a>3.4 Invariance Learning for Target Domain</h3><p>开始祭出三板斧了。</p>
<p><strong>Exemplar-invariance</strong>: 因为同一id的图片在外观上也会有很大的变化，即每一张图片都应该只与自己相似，与其他图片差别很大，因此，可以视每一张图片为一类。具体过程是，对于给定图片$x<em>{t,i}$，先计算 $x</em>{t,i}$ 的特征与其他图片在 key-memory 存储的特征的 cosine 距离，距离越大越相似。然后用这个距离去预测 $x_{t,i}$ 属于第 i 类的概率。这种预测与我见过的分类不太一样，因为分类模型一般都是直接用特征去预测类别，但这里是用距离去预测类别，或者说用距离当预测概率，还是第一次见。</p>
<script type="math/tex; mode=display">p(i|x_{t,i})=\frac{exp(K[i]^T f(x_{t,i})/\beta)}{\sum_{j=1}^{N_t}exp(K[j]^T f(x_{t,i})/\beta)}</script><p>其中 $\beta\in (0,1]$ ，用于平衡分布的趋势，记为 temperature，$\beta=0.05$，根据代码来看，$K[i]$ 表示当前 model 运行之前存储的， $f(x_{t,i})$表示当前 model 的结果，也就是说两者不一样。下面求概率的过程同理。</p>
<p>这个公式和 distillation 很像。</p>
<script type="math/tex; mode=display">q_i=\frac{exp(z_i/T)}{\sum_j exp(z_j/T)}</script><p>其中，$z_i$是类别预测概率。</p>
<p>所以分类损失可以写成：</p>
<script type="math/tex; mode=display">L_{ei}=-\log p(i|x_{t,i})</script><p><strong>Camera-invariance</strong>：视经过 StarGAN 转换的图片$\hat{x}_{t,i}$是同一类，与HHL一样，但是与HHL不同的是，HHL用于三元组损失，ECN用于分类损失，类似 Exemplar-invariance 的概率求解和loss损失，得：</p>
<script type="math/tex; mode=display">p(i|\hat{x} _ {t,i})=\frac{exp(K[i]^T f(\hat{x} _ {t,i})/\beta)}{\sum_{j=1}^{N_t}exp(K[j]^T f(\hat{x}_{t,i})/\beta)}</script><script type="math/tex; mode=display">L_{ci}=-\log p(i|\hat{x}_{t,i})</script><p>其中，$\hat{x}<em> {t,i}$是在生成的C张图片中$\lbrace \hat{x}</em> {t,i,1},…, \hat{x}_{t,i,C} \rbrace$随机选了一张。</p>
<p>这里有个问题，Exemplar Memory 中是否包含 CamStyle 生成的图片。等看代码就知道了。</p>
<p><strong>Neighborhood-invariance</strong>: 对每一张图片，在数据集中一定至少存在一张与之相同id的图片，如果能得到这些图片，那就更好了，这样就可以获得同一id不同姿态的图片。具体方法是在 exemplar memory 中计算 cos 距离，用k近邻方法得到最近的k张图片的index，记为 $M(x_{t,i},k)$，显然最近的是i. $k=6$</p>
<p>基于假设k近邻得到的图片$M(x<em>{t,i},k)$属于同一类，因此可以得到 $x</em>{t,i}$ 属于第 j 类的概率的权重是:</p>
<script type="math/tex; mode=display">w_{i,j}=\begin{cases}
\frac{1}{k}, j\not = i \\
1, j=i
\end{cases}, \forall j \in M(x_{t,i},k)</script><p>这种赋予权重的方法是把 $x<em>{t,i}$ 属于另一张图片类别的概率，而不是我之前以为的 $M(x</em>{t,i},k)$ 中的图片属于 $x_{t,i}$ 类别的概率。</p>
<p>因此损失可以写成：</p>
<script type="math/tex; mode=display">L_{n,i}=-\sum_{j\not = i} w_{i,j} \log p(j|x_{t,i}), \forall j \in M(x_{t,i},k)</script><p>其中，为了区分 Exemplar-invariance 和 Neighborhood-invariance ，这里没有再次计算 $x_{t,i}$ 属于第 i 类的损失。</p>
<p><strong>Overall loss of invariance learning</strong>: invariance learning 的总损失可以表示成：</p>
<script type="math/tex; mode=display">L_{tgt}=-\frac{1}{n_t} \sum_{i=1}^{n_t} \sum_{j \in M(x_{t,i},k)} w_{i,j} \log p(j|x^*_{t,i})</script><p>其中，$x^*<em> {t,i}$ 表示随机从$\lbrace x</em>{t,i}, \hat{x}<em> {t,i,1},…, \hat{x}</em>{t,i,C}, \rbrace$ 选一张。</p>
<p>看看代码再说这个损失的具体实现吧。</p>
<h3 id="3-5-Final-Loss-for-Network"><a href="#3-5-Final-Loss-for-Network" class="headerlink" title="3.5 Final Loss for Network"></a>3.5 Final Loss for Network</h3><script type="math/tex; mode=display">L=(1-\lambda)L_{src}+\lambda L_{tgt}</script><p>其中，$\lambda \in (0, 1]$， $\lambda=0.3$</p>
<p>这里的损失没有用常见的加法，而是一个线性组合？</p>
<h2 id="4-Experiment"><a href="#4-Experiment" class="headerlink" title="4. Experiment"></a>4. Experiment</h2><h3 id="4-1-Experiment-Setting"><a href="#4-1-Experiment-Setting" class="headerlink" title="4.1 Experiment Setting"></a>4.1 Experiment Setting</h3><p>前5个 epoch 只训练 exemplar-invariance and camera-invariance，也就是通用的交叉熵损失，5个epoch之后再加入 neighborhood-invariance。</p>
<h3 id="4-2-Parameter-Analysis"><a href="#4-2-Parameter-Analysis" class="headerlink" title="4.2 Parameter Analysis"></a>4.2 Parameter Analysis</h3><p>temperature fact $\beta$, weight of loss $\lambda$, number of candidate positive samples $k$.</p>
<p><strong>Temperature fact $\beta$</strong></p>
<img src="/2019/05/06/ECN/temperature.png" class title="different values of $\beta$">
<p>当 $\beta$ 比较小的时候，分布越陡，值越大，损失越小，结果也越好。最好的结果是 $\beta$ 在0.05 左右。同时通过表格可以看出，当 $\beta$ 变化从0.05到0.5时，rank-1下降了17。但同时，在最优解的附近也接近最优解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在蒸馏网络中，T越大，分布越平缓</span></span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">fun1 = F.softmax</span><br><span class="line">aa = torch.tensor([<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.2</span>])</span><br><span class="line">fun1(aa, dim=<span class="number">0</span>)</span><br><span class="line">tensor([<span class="number">0.2616</span>, <span class="number">0.4767</span>, <span class="number">0.2616</span>])</span><br><span class="line">bb = torch.tensor([<span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">0.2</span>])/<span class="number">0.1</span></span><br><span class="line">fun1(bb, dim=<span class="number">0</span>)</span><br><span class="line">tensor([<span class="number">0.0025</span>, <span class="number">0.9951</span>, <span class="number">0.0025</span>])</span><br></pre></td></tr></table></figure>
<p><strong>The weight of source and target losses $\lambda$</strong>:</p>
<img src="/2019/05/06/ECN/weight.png" class title="The weight of source and target losses $\lambda$">
<p>可以看出即便只有 target loss， 性能也超过 baseline， 当取其他值的时候，性能几乎不变。</p>
<p><strong>Number of positive samples $k$</strong>:</p>
<img src="/2019/05/06/ECN/number.png" class title="Number of positive samples $k$">
<p>可以看出，性能对k挺敏感的。</p>
<h3 id="4-4-Evaluation"><a href="#4-4-Evaluation" class="headerlink" title="4.4 Evaluation"></a>4.4 Evaluation</h3>
<p>通过表格中的数据集可以计算出，C+N&gt;C,N，C和N共同使用互相还有促进作用。</p>
<p>作者也在 MSMT 数据集上做了训练测试。</p>
<img src="/2019/05/06/ECN/MSMT.png" class title="performance evaluation when tested on MSMT17">
<p>感觉大家都开始在 MSMT17 上做实验了，不怎么管 CUHK 了。</p>
<h2 id="5-code"><a href="#5-code" class="headerlink" title="5. code"></a>5. code</h2><p>代码和HHL的差不多</p>
<h3 id="5-1-model"><a href="#5-1-model" class="headerlink" title="5.1 model"></a>5.1 model</h3><h4 id="5-1-1-baseline"><a href="#5-1-1-baseline" class="headerlink" title="5.1.1 baseline"></a>5.1.1 baseline</h4><p>有以下几个改变：</p>
<ul>
<li>conv1 ~ layer2 的参数不再更新</li>
<li>source: layer4-avgpool-Linear(4096)-bn-relu-drop(0.5)-Linear(num_class)</li>
<li>target: layer4-avgpool-Linear(4096)-bn-F.normalize-drop(0.5)</li>
</ul>
<p>Question：先normalize后drop的话就不满足归一化的定义了</p>
<p>Question: conv1~layer2 固定参数是有什么含义吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResNet</span>(nn.Module):</span><br><span class="line">    __factory = &#123;</span><br><span class="line">        <span class="number">18</span>: torchvision.models.resnet18,</span><br><span class="line">        <span class="number">34</span>: torchvision.models.resnet34,</span><br><span class="line">        <span class="number">50</span>: torchvision.models.resnet50,</span><br><span class="line">        <span class="number">101</span>: torchvision.models.resnet101,</span><br><span class="line">        <span class="number">152</span>: torchvision.models.resnet152,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, depth, pretrained=<span class="literal">True</span>, cut_at_pooling=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">                 num_features=<span class="number">0</span>, norm=<span class="literal">False</span>, dropout=<span class="number">0</span>, num_classes=<span class="number">0</span>, num_triplet_features=<span class="number">0</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(ResNet, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.depth = depth</span><br><span class="line">        self.pretrained = pretrained</span><br><span class="line">        self.cut_at_pooling = cut_at_pooling</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Construct base (pretrained) resnet</span></span><br><span class="line">        <span class="keyword">if</span> depth <span class="keyword">not</span> <span class="keyword">in</span> ResNet.__factory:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&quot;Unsupported depth:&quot;</span>, depth)</span><br><span class="line">        self.base = ResNet.__factory[depth](pretrained=pretrained)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Fix layers [conv1 ~ layer2]</span></span><br><span class="line">        fixed_names = []</span><br><span class="line">        <span class="keyword">for</span> name, module <span class="keyword">in</span> self.base._modules.items():</span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">&quot;layer3&quot;</span>:</span><br><span class="line">                <span class="comment"># assert fixed_names == [&quot;conv1&quot;, &quot;bn1&quot;, &quot;relu&quot;, &quot;maxpool&quot;, &quot;layer1&quot;, &quot;layer2&quot;]</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            fixed_names.append(name)</span><br><span class="line">            <span class="keyword">for</span> param <span class="keyword">in</span> module.parameters():</span><br><span class="line">                param.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.cut_at_pooling:</span><br><span class="line">            self.num_features = num_features</span><br><span class="line">            self.norm = norm</span><br><span class="line">            self.dropout = dropout</span><br><span class="line">            self.has_embedding = num_features &gt; <span class="number">0</span></span><br><span class="line">            self.num_classes = num_classes</span><br><span class="line">            self.num_triplet_features = num_triplet_features</span><br><span class="line"></span><br><span class="line">            self.l2norm = Normalize(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            out_planes = self.base.fc.in_features</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Append new layers</span></span><br><span class="line">            <span class="keyword">if</span> self.has_embedding:</span><br><span class="line">                self.feat = nn.Linear(out_planes, self.num_features)</span><br><span class="line">                self.feat_bn = nn.BatchNorm1d(self.num_features)</span><br><span class="line">                init.kaiming_normal_(self.feat.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>)</span><br><span class="line">                init.constant_(self.feat.bias, <span class="number">0</span>)</span><br><span class="line">                init.constant_(self.feat_bn.weight, <span class="number">1</span>)</span><br><span class="line">                init.constant_(self.feat_bn.bias, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Change the num_features to CNN output channels</span></span><br><span class="line">                self.num_features = out_planes</span><br><span class="line">            <span class="keyword">if</span> self.dropout &gt;= <span class="number">0</span>:</span><br><span class="line">                self.drop = nn.Dropout(self.dropout)</span><br><span class="line">            <span class="keyword">if</span> self.num_classes &gt; <span class="number">0</span>:</span><br><span class="line">                self.classifier = nn.Linear(self.num_features, self.num_classes)</span><br><span class="line">                init.normal_(self.classifier.weight, std=<span class="number">0.001</span>)</span><br><span class="line">                init.constant_(self.classifier.bias, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.pretrained:</span><br><span class="line">            self.reset_params()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, output_feature=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">for</span> name, module <span class="keyword">in</span> self.base._modules.items():</span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">&#x27;avgpool&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = module(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.cut_at_pooling:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        x = F.avg_pool2d(x, x.size()[<span class="number">2</span>:])</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> output_feature == <span class="string">&#x27;pool5&#x27;</span>:</span><br><span class="line">            x = F.normalize(x)</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.has_embedding:</span><br><span class="line">            x = self.feat(x)</span><br><span class="line">            x = self.feat_bn(x)</span><br><span class="line">            tgt_feat = F.normalize(x)</span><br><span class="line">            tgt_feat = self.drop(tgt_feat)</span><br><span class="line">            <span class="keyword">if</span> output_feature == <span class="string">&#x27;tgt_feat&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> tgt_feat</span><br><span class="line">        <span class="keyword">if</span> self.norm:</span><br><span class="line">            x = F.normalize(x)</span><br><span class="line">        <span class="keyword">elif</span> self.has_embedding:</span><br><span class="line">            x = F.relu(x)</span><br><span class="line">        <span class="keyword">if</span> self.dropout &gt; <span class="number">0</span>:</span><br><span class="line">            x = self.drop(x)</span><br><span class="line">        <span class="keyword">if</span> self.num_classes &gt; <span class="number">0</span>:</span><br><span class="line">            x = self.classifier(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset_params</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> self.modules():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(m, nn.Conv2d):</span><br><span class="line">                init.kaiming_normal(m.weight, mode=<span class="string">&#x27;fan_out&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    init.constant(m.bias, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.BatchNorm2d):</span><br><span class="line">                init.constant(m.weight, <span class="number">1</span>)</span><br><span class="line">                init.constant(m.bias, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(m, nn.Linear):</span><br><span class="line">                init.normal(m.weight, std=<span class="number">0.001</span>)</span><br><span class="line">                <span class="keyword">if</span> m.bias <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    init.constant(m.bias, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>L2 正则化定义了专门的层，但没有使用，可能是嫌慢吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Normalize</span>(nn.Module):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, power=<span class="number">2</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Normalize, self).__init__()</span><br><span class="line">        self.power = power</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        norm = x.<span class="built_in">pow</span>(self.power).<span class="built_in">sum</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>).<span class="built_in">pow</span>(<span class="number">1.</span>/self.power)</span><br><span class="line">        out = x.div(norm)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-InvNet"><a href="#5-1-2-InvNet" class="headerlink" title="5.1.2 InvNet"></a>5.1.2 InvNet</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pytorch&gt;=1.0.0</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, autograd</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable, Function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 这应该是最新版的自定义 Function 的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExemplarMemory</span>(<span class="title class_ inherited__">Function</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, em, alpha=<span class="number">0.01</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(ExemplarMemory, self).__init__()</span><br><span class="line">        self.em = em</span><br><span class="line">        self.alpha = alpha</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs, targets</span>):</span><br><span class="line">        <span class="comment"># inputs: b*2048, targets: b*1 (index)</span></span><br><span class="line">        self.save_for_backward(inputs, targets)</span><br><span class="line">        <span class="comment"># outputs: b*12936</span></span><br><span class="line">        outputs = inputs.mm(self.em.t())</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, grad_outputs</span>):</span><br><span class="line">        <span class="comment"># 这个backward 主要用于更新 em</span></span><br><span class="line">        inputs, targets = self.saved_tensors</span><br><span class="line">        grad_inputs = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.needs_input_grad[<span class="number">0</span>]:</span><br><span class="line">            grad_inputs = grad_outputs.mm(self.em)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(inputs, targets):</span><br><span class="line">            self.em[y] = self.alpha * self.em[y] + (<span class="number">1.</span> - self.alpha) * x</span><br><span class="line">            self.em[y] /= self.em[y].norm()</span><br><span class="line">        <span class="keyword">return</span> grad_inputs, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Invariance learning loss</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InvNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_features, num_classes, beta=<span class="number">0.05</span>, knn=<span class="number">6</span>, alpha=<span class="number">0.01</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(InvNet, self).__init__()</span><br><span class="line">        self.device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">        self.num_features = num_features</span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.alpha = alpha  <span class="comment"># Memory update rate</span></span><br><span class="line">        self.beta = beta  <span class="comment"># Temperature fact</span></span><br><span class="line">        self.knn = knn  <span class="comment"># Knn for neighborhood invariance</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Exemplar memory, 12936x2048</span></span><br><span class="line">        self.em = nn.Parameter(torch.zeros(num_classes, num_features))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs, targets, epoch=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># inputs: b*2048, targets: b*1 (index)</span></span><br><span class="line">        alpha = self.alpha * epoch</span><br><span class="line">        <span class="comment"># 每次都是重建一个 ExemplarMemory，我觉得可能是因为alpha每次要改变。</span></span><br><span class="line">        inputs = ExemplarMemory(self.em, alpha=alpha)(inputs, targets)</span><br><span class="line">        <span class="comment"># inputs: b*12936</span></span><br><span class="line"></span><br><span class="line">        inputs /= self.beta</span><br><span class="line">        <span class="keyword">if</span> self.knn &gt; <span class="number">0</span> <span class="keyword">and</span> epoch &gt; <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># With neighborhood invariance</span></span><br><span class="line">            loss = self.smooth_loss(inputs, targets)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Without neighborhood invariance</span></span><br><span class="line">            loss = F.cross_entropy(inputs, targets)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smooth_loss</span>(<span class="params">self, inputs, targets</span>):</span><br><span class="line">        <span class="comment"># overall loss of invariance loss</span></span><br><span class="line">        <span class="comment"># inputs: b*12936, targets: b*1 (index)</span></span><br><span class="line">        targets = self.smooth_hot(inputs.detach().clone(), targets.detach().clone(), self.knn)</span><br><span class="line">        <span class="comment"># targets: b*12936, weights</span></span><br><span class="line">        outputs = F.log_softmax(inputs, dim=<span class="number">1</span>)</span><br><span class="line">        loss = - (targets * outputs)</span><br><span class="line">        loss = loss.<span class="built_in">sum</span>(dim=<span class="number">1</span>)</span><br><span class="line">        loss = loss.mean(dim=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smooth_hot</span>(<span class="params">self, inputs, targets, k=<span class="number">6</span></span>):</span><br><span class="line">        <span class="comment"># Sort</span></span><br><span class="line">        <span class="comment"># inputs: b*12936, targets: b*1 (index)</span></span><br><span class="line">        <span class="comment"># targets_onehot: b*12936</span></span><br><span class="line">        <span class="comment"># targets_onehot: 记录的是当前样本属于其他类的概率的权重 1/k or 1</span></span><br><span class="line">        _, index_sorted = torch.sort(inputs, dim=<span class="number">1</span>, descending=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        ones_mat = torch.ones(targets.size(<span class="number">0</span>), k).to(self.device)</span><br><span class="line">        targets = torch.unsqueeze(targets, <span class="number">1</span>)</span><br><span class="line">        targets_onehot = torch.zeros(inputs.size()).to(self.device)</span><br><span class="line">        <span class="comment"># 这里的 weights 应该是 1/k， 因为每个值都一样，所以 softmax 之后就是 1/k</span></span><br><span class="line">        <span class="comment"># 猜测作者这里刚开始不是直接想要 1/k 的权重，而是根据距离远近赋予权重，比如选</span></span><br><span class="line">        <span class="comment"># 择6个最近的，然后根据相似性赋予权重（等同于概率的求解）</span></span><br><span class="line">        <span class="comment"># Question:weights = F.softmax(ones_mat, dim=1)</span></span><br><span class="line">        <span class="comment"># targets_onehot.scatter_(1, index_sorted[:, 0:k], ones_mat * weights)</span></span><br><span class="line">        weights = F.softmax(ones_mat, dim=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 根据位置填充权重</span></span><br><span class="line">        targets_onehot.scatter_(<span class="number">1</span>, index_sorted[:, <span class="number">0</span>:k], ones_mat * weights)</span><br><span class="line">        <span class="comment"># Question: 怎么保证前k个就一定没有index？</span></span><br><span class="line">        targets_onehot.scatter_(<span class="number">1</span>, targets, <span class="built_in">float</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> targets_onehot</span><br></pre></td></tr></table></figure>
<p>补充 <strong>gather</strong> 和 <strong>scatter</strong> 的用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gather</span></span><br><span class="line"><span class="comment"># torch.gather(input, dim, index, out=None)</span></span><br><span class="line"><span class="comment"># output[i][j][k]=input[index[[i][j][k]]][j][k] # if dim=0</span></span><br><span class="line"><span class="comment"># output[i][j][k]=input[i][index[[i][j][k]]][k] # if dim=1</span></span><br><span class="line"><span class="comment"># output[i][j][k]=input[i][j][index[[i][j][k]]] # if dim=2</span></span><br><span class="line"><span class="comment"># 光看公式很绕，</span></span><br><span class="line"><span class="comment"># 其中 out 的size和 index 的size相同</span></span><br><span class="line"><span class="comment"># input: a0*a1*a2*...ai-1*ai*ai+1,...,an-1</span></span><br><span class="line"><span class="comment"># index: a0*a1*a2*...ai-1*y*ai+1,...,an-1</span></span><br><span class="line"><span class="comment"># output:a0*a1*a2*...ai-1*y*ai+1,...,an-1</span></span><br><span class="line"><span class="comment"># 除了第dim维，其他维度上 index 的size和input的size相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者我们换个角度，不要管公式，把index分成y份，index_0，index_1, ..., index_y-1</span></span><br><span class="line"><span class="comment"># index_0: a0*a1*a2*...ai-1*1*ai+1,...,an-1</span></span><br><span class="line"><span class="comment"># index_0 就是在第i个维度上选取对应位置第y[0]个通道的数字，</span></span><br><span class="line"><span class="comment"># 以此类推，下面用二维矩阵做个示范</span></span><br><span class="line"><span class="comment"># 可以理解成降维</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="built_in">input</span> = torch.Tensor([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">2.</span>],</span><br><span class="line">        [<span class="number">3.</span>, <span class="number">4.</span>]])</span><br><span class="line"><span class="comment"># [0,0] 表示选取第0维第0个通道的数字，第0维第0个通道的数字</span></span><br><span class="line">torch.gather(<span class="built_in">input</span>, <span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">0</span>]]) )</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">2.</span>]])</span><br><span class="line"><span class="comment"># [0,0] 表示选取第0维第0个通道的数字，第0维第1个通道的数字</span></span><br><span class="line">torch.gather(<span class="built_in">input</span>, <span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">1</span>]]) )</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">4.</span>]])</span><br><span class="line">torch.gather(<span class="built_in">input</span>, <span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>,<span class="number">1</span>], [<span class="number">0</span>,<span class="number">1</span>], [<span class="number">0</span>,<span class="number">1</span>]]) )</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">4.</span>]])</span><br><span class="line"><span class="comment"># 三维矩阵</span></span><br><span class="line"><span class="comment"># 三维矩阵更好理解，可以通过投射的方式理解</span></span><br><span class="line">a = torch.arange(<span class="number">0</span>,<span class="number">27</span>).view(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 第0维第0个通道</span></span><br><span class="line">tensor([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">         [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">         [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]],</span><br><span class="line"><span class="comment"># 第0维第1个通道</span></span><br><span class="line">        [[ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">         [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>],</span><br><span class="line">         [<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>]],</span><br><span class="line"><span class="comment"># 第0维第2个通道</span></span><br><span class="line">        [[<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">         [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">         [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>]]])</span><br><span class="line"><span class="comment"># 在对应位置，分别选取第0维的第0个，第1个，第2个通道的数字</span></span><br><span class="line">c = [[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]]</span><br><span class="line">index = torch.LongTensor(c)</span><br><span class="line">a.gather(<span class="number">0</span>, index)</span><br><span class="line">tensor([[[ <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">         [ <span class="number">3</span>, <span class="number">13</span>, <span class="number">23</span>],</span><br><span class="line">         [ <span class="number">6</span>, <span class="number">16</span>, <span class="number">26</span>]]])</span><br><span class="line"><span class="comment"># output的第0维第0个通道：分别选取0,1,2</span></span><br><span class="line"><span class="comment"># output的第0维第1个通道：分别选取0,1,0</span></span><br><span class="line">c = [[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]], [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]]</span><br><span class="line">index = torch.LongTensor(c)</span><br><span class="line">a.gather(<span class="number">0</span>, index)</span><br><span class="line">tensor([[[ <span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">         [ <span class="number">3</span>, <span class="number">13</span>, <span class="number">23</span>],</span><br><span class="line">         [ <span class="number">6</span>, <span class="number">16</span>, <span class="number">26</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">0</span>, <span class="number">10</span>,  <span class="number">2</span>],</span><br><span class="line">         [ <span class="number">3</span>, <span class="number">13</span>,  <span class="number">5</span>],</span><br><span class="line">         [ <span class="number">6</span>, <span class="number">16</span>,  <span class="number">8</span>]]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scatter</span></span><br><span class="line"><span class="comment"># torch.scatter_(dim, index, src)</span></span><br><span class="line"><span class="comment"># 可以理解成gather的相反操作</span></span><br><span class="line"><span class="comment"># src 和 index 的size相同</span></span><br><span class="line"><span class="comment"># out[index[i][j][k]][j][k]=src[i][j][k] if dim=0</span></span><br><span class="line"><span class="comment"># out[i][index[i][j][k]][k]=src[i][j][k] if dim=1</span></span><br><span class="line"><span class="comment"># out[i][j][index[i][j][k]]=src[i][j][k] if dim=2</span></span><br><span class="line">x = torch.rand(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"> <span class="number">0.4319</span>  <span class="number">0.6500</span>  <span class="number">0.4080</span>  <span class="number">0.8760</span>  <span class="number">0.2355</span></span><br><span class="line"> <span class="number">0.2609</span>  <span class="number">0.4711</span>  <span class="number">0.8486</span>  <span class="number">0.8573</span>  <span class="number">0.1029</span></span><br><span class="line">[torch.FloatTensor of size 2x5]</span><br><span class="line">torch.zeros(<span class="number">3</span>, <span class="number">5</span>).scatter_(<span class="number">0</span>, torch.LongTensor([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]), x)</span><br><span class="line"> <span class="number">0.4319</span>  <span class="number">0.4711</span>  <span class="number">0.8486</span>  <span class="number">0.8760</span>  <span class="number">0.2355</span></span><br><span class="line"> <span class="number">0.0000</span>  <span class="number">0.6500</span>  <span class="number">0.0000</span>  <span class="number">0.8573</span>  <span class="number">0.0000</span></span><br><span class="line"> <span class="number">0.2609</span>  <span class="number">0.0000</span>  <span class="number">0.4080</span>  <span class="number">0.0000</span>  <span class="number">0.1029</span></span><br><span class="line">[torch.FloatTensor of size 3x5]</span><br></pre></td></tr></table></figure>
<h3 id="5-2-data"><a href="#5-2-data" class="headerlink" title="5.2 data"></a>5.2 data</h3><p>对于 target domain 中的图片，每次都是从原始图片和生成图片组成的集合中随机取一张图片，当选取的 camid 是原始图片的 camid 时，取原始图片，当取到的 camid 不是原始图片的 camid 时，取生成图片，实际只使用了 C-1 张生成图片和 1 张原始图片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reid/utils/data/preprocessor.py</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_single_item</span>(<span class="params">self, index</span>):</span><br><span class="line">        fname, pid, camid = self.dataset[index]</span><br><span class="line">        sel_cam = torch.randperm(self.num_cam)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> sel_cam == camid:</span><br><span class="line">            fpath = osp.join(self.root, fname)</span><br><span class="line">            img = Image.<span class="built_in">open</span>(fpath).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;msmt&#x27;</span> <span class="keyword">in</span> self.root:</span><br><span class="line">                fname = fname[:-<span class="number">4</span>] + <span class="string">&#x27;_fake_&#x27;</span> + <span class="built_in">str</span>(sel_cam.numpy() + <span class="number">1</span>) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                fname = fname[:-<span class="number">4</span>] + <span class="string">&#x27;_fake_&#x27;</span> + <span class="built_in">str</span>(camid + <span class="number">1</span>) + <span class="string">&#x27;to&#x27;</span> + <span class="built_in">str</span>(sel_cam.numpy() + <span class="number">1</span>) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            fpath = osp.join(self.camstyle_root, fname)</span><br><span class="line">            img = Image.<span class="built_in">open</span>(fpath).convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="keyword">return</span> img, fname, pid, index</span><br></pre></td></tr></table></figure>
<h3 id="5-3-optimizer"><a href="#5-3-optimizer" class="headerlink" title="5.3 optimizer"></a>5.3 optimizer</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个写的可以，清晰明了，只是在HHL中，只有classifier层设置为1.0，其他新层则是0.0，这里则把新层全部设置成了1.0，应该也是实验所得吧。</span></span><br><span class="line">base_param_ids = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">id</span>, model.module.base.parameters()))</span><br><span class="line"></span><br><span class="line">base_params_need_for_grad = <span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad, model.module.base.parameters())</span><br><span class="line"></span><br><span class="line">new_params = [p <span class="keyword">for</span> p <span class="keyword">in</span> model.parameters() <span class="keyword">if</span></span><br><span class="line">                <span class="built_in">id</span>(p) <span class="keyword">not</span> <span class="keyword">in</span> base_param_ids]</span><br><span class="line">param_groups = [</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: base_params_need_for_grad, <span class="string">&#x27;lr_mult&#x27;</span>: <span class="number">0.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;params&#x27;</span>: new_params, <span class="string">&#x27;lr_mult&#x27;</span>: <span class="number">1.0</span>&#125;]</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.SGD(param_groups, lr=args.lr,</span><br><span class="line">                            momentum=args.momentum,</span><br><span class="line">                            weight_decay=args.weight_decay,</span><br><span class="line">                            nesterov=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-4-train"><a href="#5-4-train" class="headerlink" title="5.4 train"></a>5.4 train</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py and reid/trainers.py</span></span><br><span class="line"><span class="comment"># self.model: ResNet-50</span></span><br><span class="line"><span class="comment"># self.model_inv : InvNet</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># source domain 的交叉熵损失</span></span><br><span class="line">inputs, pids = self._parse_data(inputs)</span><br><span class="line">outputs = self.model(inputs)</span><br><span class="line">source_pid_loss = self.pid_criterion(outputs, pids)</span><br><span class="line"><span class="comment"># target domain 的损失</span></span><br><span class="line">outputs = self.model(inputs_target, <span class="string">&#x27;tgt_feat&#x27;</span>)</span><br><span class="line">loss_un = self.model_inv(outputs, index_target, epoch=epoch)</span><br><span class="line"><span class="comment"># overall loss</span></span><br><span class="line">loss = (<span class="number">1</span> - self.lmd) * source_pid_loss + self.lmd * loss_un</span><br></pre></td></tr></table></figure>
<p>知识点补充：因为 ResNet-50 的 conv1~layer2 的参数已经设置不参与更新，自然这些层的 bn 层也应该是 eval 状态。</p>
<p>Question: 上面的知识点补充是否正确？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_model_train</span>(<span class="params">self</span>):</span><br><span class="line">    self.model.train()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fix first BN</span></span><br><span class="line">    fixed_bns = []</span><br><span class="line">    <span class="keyword">for</span> idx, (name, module) <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.model.module.named_modules()):</span><br><span class="line">        <span class="keyword">if</span> name.find(<span class="string">&quot;layer3&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># assert len(fixed_bns) == 22</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> name.find(<span class="string">&quot;bn&quot;</span>) != -<span class="number">1</span>:</span><br><span class="line">            fixed_bns.append(name)</span><br><span class="line">            module.<span class="built_in">eval</span>()</span><br><span class="line"><span class="built_in">len</span>(fixed_bns)</span><br><span class="line"><span class="number">22</span></span><br><span class="line">[<span class="string">&#x27;bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.bn3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.1.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.1.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.1.bn3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.2.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.2.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.2.bn3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.0.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.0.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.0.bn3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.1.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.1.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.1.bn3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.2.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.2.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.2.bn3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.3.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.3.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer2.3.bn3&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>到此应该代码全部看完了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/person-re-id/" rel="tag"># person re-id</a>
              <a href="/tags/cross-domain/" rel="tag"># cross domain</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/05/05/Dual-Attention-Network-for-Scene-Segmentation/" rel="prev" title="Dual Attention Network for Scene Segmentation">
      <i class="fa fa-chevron-left"></i> Dual Attention Network for Scene Segmentation
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/10/residual-attention_and_CBAM_GCNet/" rel="next" title="residual_attention">
      residual_attention <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Introduction"><span class="nav-number">2.</span> <span class="nav-text">1. Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Related-Work"><span class="nav-number">3.</span> <span class="nav-text">2. Related Work</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-The-Proposed-Method"><span class="nav-number">4.</span> <span class="nav-text">3. The Proposed Method</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Overview-of-Framework"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 Overview of Framework</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Supervised-Learning-for-Source-Domain"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 Supervised Learning for Source Domain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Exemplar-Memory"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 Exemplar Memory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Invariance-Learning-for-Target-Domain"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 Invariance Learning for Target Domain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Final-Loss-for-Network"><span class="nav-number">4.5.</span> <span class="nav-text">3.5 Final Loss for Network</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Experiment"><span class="nav-number">5.</span> <span class="nav-text">4. Experiment</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Experiment-Setting"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 Experiment Setting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Parameter-Analysis"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 Parameter Analysis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-Evaluation"><span class="nav-number">5.3.</span> <span class="nav-text">4.4 Evaluation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-code"><span class="nav-number">6.</span> <span class="nav-text">5. code</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-model"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-baseline"><span class="nav-number">6.1.1.</span> <span class="nav-text">5.1.1 baseline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-InvNet"><span class="nav-number">6.1.2.</span> <span class="nav-text">5.1.2 InvNet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-data"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-optimizer"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 optimizer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-train"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 train</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">TianJiajie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TianJiajie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
